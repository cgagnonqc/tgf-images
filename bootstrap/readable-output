#! /usr/bin/env python3

import fileinput
import os
import re
import sys

from difflib import ndiff
from collections import Sequence
from math import log10, ceil
from itertools import groupby
from colorama import Fore, Back, Style, init


class UnbufferedStream(object):
    def __init__(self, stream):
        self.stream = stream

    def write(self, data):
        self.stream.write(data)
        self.stream.flush()

    def writelines(self, datas):
        self.stream.writelines(datas)
        self.stream.flush()

    def __getattr__(self, attr):
        return getattr(self.stream, attr)


def color_diff(source, target, strikeout=True, window=5, formatted=True):
    """
    Generate a colored array of differences between multi-line strings

    :param source: The original value
    :param target: The new value
    :param strikeout: Specify if strikeout should be added on deleted parts (default = False)
    :param window: Specify the window of lines to generate before and after changes (default 5)
    :param formatted: Specified if the results should be formatted as string or returned as tuple
    :return: An array of string
    """
    source = source.splitlines() if isinstance(source, str) else source
    target = target.splitlines() if isinstance(target, str) else target
    assert isinstance(source, Sequence) and isinstance(target, Sequence)

    strikeout = u'\u0336' if strikeout else ''
    diff = [(d[0], d[2:]) for d in ndiff(source, target)]

    count = source_line = target_line = 0
    result = []
    len_diff = len(diff)

    # We use this table to determine the color used to display the change
    color_table = {
        '-': Fore.RED+Style.BRIGHT,
        '+': Fore.GREEN,
        '*': Fore.YELLOW,
        ' ': Style.RESET_ALL,
    }

    # We use this table to determine the increment for line count in source and destination
    increment_table = {
        '-': (1, 0),
        '+': (0, 1),
        ' ': (1, 1),
        '*': (1, 1),
    }

    while count < len_diff:
        difference_type, line = diff[count]

        if difference_type == '-':
            # Find the next differences that are relative to the current changed line
            next_diffs = [(d, l) for d, l in diff[count + 1:count + 4] if d not in (' ', '-')]
                
            if '?' in [d[0] for d in next_diffs]:
                # This is a modified line
                if next_diffs[-1][0] == '+' and next_diffs[-2][0] == '+':
                    # The last item must be a '?'
                    next_diffs.pop()

                count += len(next_diffs)
                difference_type = '*'

                # We transform the result from difflib to be able to combine changes on single line
                insert_line = fill((l for d, l in next_diffs if d == '+'), 1, '')[0]

                new_line = color = back = ''

                for d in ndiff(line, insert_line):
                    new_color = color_table[d[0]]
                    if d[0] == '+' and d[2] == ' ':
                        back = Back.LIGHTBLACK_EX
                        new_line += back
                    if new_color != color:
                        new_line += new_color
                        color = new_color
                    new_line += d[2] + (strikeout if d[0] == '-' else '')
                    if back:
                        new_line += Back.RESET
                line = new_line

        color = color_table.get(difference_type)
        line_increment = increment_table.get(difference_type, (0, 0))

        source_line += line_increment[0]
        source_no = source_line if difference_type != '+' else ''
        target_line += line_increment[1]
        target_no = target_line if difference_type != '-' else ''

        if color:
            if difference_type == '-':
                line = strikeout.join(line) + strikeout
            result.append((
                source_no,
                target_no,
                (color if difference_type != '*' else '') + line,
                str(difference_type),
                str(color)
            ))

        count += 1

    if not isinstance(window, bool) or window:  # Could be 0, so we explicitly check for False
        window = int(round(window))

        temp = [[0, r] for r in result]

        for n, r in enumerate(temp):
            if r[1][3] != ' ':
                # We mark the item around the change to keep them in the change window
                for inc, val in enumerate(temp[max(n-window, 0):n+window+1]):
                    val[0] = n-window+inc+1

        empty = '', '', '...', '', ''
        result = (next(v)[1] for k, v in groupby(((flg, r if flg else empty) for flg, r in temp), lambda t: t[0]))

    if formatted:
        # We compute the format used to output the result according to the number of lines
        fmt = '{{:>{0}}}'.format(int(ceil(log10(max(len(source), len(target))))))

        def fn(no): return fmt.format(no)

        result = (
            u'{col}{s} {t}{reset} {line}'.format(
                col=color, s=fn(source), t=fn(target if source != target else ''), line=line, reset=Style.RESET_ALL
            )
            for source, target, line, dif, color in result
        )

    return result


def fill(enumerable, min_length, default_fill=None):
    """
    Ensure that an array has the minimum length desired

    :param enumerable: Any iterable
    :param min_length: The desired length
    :param default_fill: The default value used to fill missing values

    :return: An array with at least min_length elements
    """
    if isinstance(enumerable, str):
        missing = min_length - len(enumerable)
        return enumerable + (default_fill or ' ')*missing

    result = list(enumerable)
    missing = min_length - len(result)
    if missing > 0:
        result += (default_fill for _ in range(missing))
    return result


def main():
    try:
        sys.stdout = UnbufferedStream(sys.stdout)
        regexDiff = re.compile(r'(.*:\s*)? "(.*)?" => "(.*)?"', flags=0)
        regexNew = re.compile(r'(.*:\s*)? "(.*)?"', flags=0)
        # We split the definition of the string here just to not match the words that represent secrets
        regexSecret = re.compile(r'^(.*?(?:\s+echo-secret\s*|\s+password:\s*|PRIVATE'+' KEY-----)).*$', flags=0)
        max_diff_line = int(os.getenv('MAX_DIFF', 50))
        space = ' '*9
        msg_max = "{1}{3}Too many differences, set MAX_DIFF to get more than {0} items{2}".format(max_diff_line, Fore.YELLOW, Fore.RESET, space)

        for line in fileinput.input():
            try:
                matches = regexSecret.match(line)
                if matches:
                    print(matches.group(1), '*'*25)
                    continue
                elif '\\n' in line:
                    matches = regexDiff.match(line)
                    if matches:
                        # The content has changed
                        print(matches.group(1))
                        source = matches.group(2).replace('\\n', "\n").replace('\\"', '"')
                        target = matches.group(3).replace('\\n', "\n").replace('\\"', '"')
                        for i, diff in enumerate(color_diff(source, target)):
                            print(space, diff, Fore.RESET)
                            if i > max_diff_line-2 and max_diff_line != 0:
                                print(msg_max)
                                break
                        continue

                    matches = regexNew.match(line)
                    if matches:
                        # The content is new
                        print(matches.group(1))
                        target = matches.group(2).replace('\\n', "\n").replace('\\"', '"')
                        for i, diff in enumerate(color_diff("", target)):
                            print(space, diff, Fore.RESET)
                            if i > max_diff_line-2 and max_diff_line != 0:
                                print(msg_max)
                                break
                        continue

                print(line, end='')
            except KeyboardInterrupt:
                raise
            except Exception as e:
                print(line)
                print("{}{}".format(Fore.RED, e), file=sys.stderr)
    except KeyboardInterrupt:
        print("\nProcessing interrupted")
    except:
        raise

    print(Style.RESET_ALL, end='')


if __name__ == '__main__':
    main()
